import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import React, { Component } from 'react';
import { getStackFrames } from './react-error-overlay/utils/getStackFrames';
import StackTrace from './react-error-overlay/containers/StackTrace';
import openFile from './openFile';
var rootStyle = {
  padding: '5px 10px'
};
export var TraceTab = /*#__PURE__*/function (_Component) {
  _inherits(TraceTab, _Component);

  var _super = _createSuper(TraceTab);

  function TraceTab() {
    var _this;

    _classCallCheck(this, TraceTab);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      stackFrames: []
    });

    _defineProperty(_assertThisInitialized(_this), "onStackLocationClicked", function () {
      var fileLocation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // console.log("Stack location args: ", ...args);
      var fileName = fileLocation.fileName,
          lineNumber = fileLocation.lineNumber;

      if (fileName && lineNumber) {
        var matchingStackFrame = _this.state.stackFrames.find(function (stackFrame) {
          var matches = stackFrame._originalFileName === fileName && stackFrame._originalLineNumber === lineNumber || stackFrame.fileName === fileName && stackFrame.lineNumber === lineNumber;
          return matches;
        }); // console.log("Matching stack frame: ", matchingStackFrame);


        if (matchingStackFrame) {
          /*
          const frameIndex = this.state.stackFrames.indexOf(matchingStackFrame);
          const originalStackFrame = parsedFramesNoSourcemaps[frameIndex];
          console.log("Original stack frame: ", originalStackFrame);
          */
          _this.props.openFile(fileName, lineNumber, matchingStackFrame);
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "openDocs", function (e) {
      e.stopPropagation();
      window.open('https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/Features/Trace.md');
    });

    return _this;
  }

  _createClass(TraceTab, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // console.log("StackTraceTab mounted");
      this.checkForStackTrace();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var action = prevProps.action,
          actions = prevProps.actions;

      if (action !== this.props.action || actions !== this.props.actions) {
        this.checkForStackTrace();
      }
    }
  }, {
    key: "checkForStackTrace",
    value: function checkForStackTrace() {
      var _this2 = this;

      var _this$props = this.props,
          action = _this$props.action,
          liftedActionsById = _this$props.actions;

      if (!action) {
        return;
      }

      var liftedActions = Object.values(liftedActionsById);
      var liftedAction = liftedActions.find(function (liftedAction) {
        return liftedAction.action === action;
      });

      if (liftedAction && typeof liftedAction.stack === 'string') {
        var deserializedError = Object.assign(new Error(), {
          stack: liftedAction.stack
        });
        getStackFrames(deserializedError).then(function (stackFrames) {
          _this2.setState({
            stackFrames: stackFrames,
            currentError: deserializedError
          });
        }).catch(function () {// noop
        });
      } else {
        this.setState({
          stackFrames: [],
          showDocsLink: !!liftedAction.action && !!liftedAction.action.type && liftedAction.action.type !== '@@INIT'
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$state = this.state,
          stackFrames = _this$state.stackFrames,
          showDocsLink = _this$state.showDocsLink;

      if (showDocsLink) {
        return /*#__PURE__*/React.createElement("div", {
          style: rootStyle
        }, "To enable tracing action calls, you should set `trace` option to `true` for Redux DevTools enhancer. Refer to", ' ', /*#__PURE__*/React.createElement("a", {
          href: "#",
          onClick: this.openDocs
        }, "this page"), ' ', "for more details.");
      }

      return /*#__PURE__*/React.createElement("div", {
        style: rootStyle
      }, /*#__PURE__*/React.createElement(StackTrace, {
        stackFrames: stackFrames,
        errorName: "N/A",
        contextSize: 3,
        editorHandler: this.onStackLocationClicked
      }));
    }
  }]);

  return TraceTab;
}(Component);

_defineProperty(TraceTab, "defaultProps", {
  openFile: openFile
});