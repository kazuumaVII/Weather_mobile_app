import _typeof from "@babel/runtime/helpers/typeof";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";

/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import path from 'path-browserify';
import StackFrame from './stack-frame';
import { getSourceMap } from './getSourceMap';
import { getLinesAround } from './getLinesAround';

function count(search, string) {
  // Count starts at -1 becuse a do-while loop always runs at least once
  var count = -1,
      index = -1;

  do {
    // First call or the while case evaluated true, meaning we have to make
    // count 0 or we found a character
    ++count; // Find the index of our search string, starting after the previous index

    index = string.indexOf(search, index + 1);
  } while (index !== -1);

  return count;
}
/**
 * Turns a set of mapped <code>StackFrame</code>s back into their generated code position and enhances them with code.
 * @param {string} fileUri The URI of the <code>bundle.js</code> file.
 * @param {StackFrame[]} frames A set of <code>StackFrame</code>s which are already mapped and missing their generated positions.
 * @param {number} [fileContents=3] The number of lines to provide before and after the line specified in the <code>StackFrame</code>.
 */


function unmap(_x, _x2) {
  return _unmap.apply(this, arguments);
}

function _unmap() {
  _unmap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_fileUri, frames) {
    var contextLines,
        fileContents,
        fileUri,
        map,
        _args = arguments;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            contextLines = _args.length > 2 && _args[2] !== undefined ? _args[2] : 3;
            fileContents = _typeof(_fileUri) === 'object' ? _fileUri.contents : null;
            fileUri = _typeof(_fileUri) === 'object' ? _fileUri.uri : _fileUri;

            if (!(fileContents == null)) {
              _context.next = 7;
              break;
            }

            _context.next = 6;
            return fetch(fileUri).then(function (res) {
              return res.text();
            });

          case 6:
            fileContents = _context.sent;

          case 7:
            _context.next = 9;
            return getSourceMap(fileUri, fileContents);

          case 9:
            map = _context.sent;
            return _context.abrupt("return", frames.map(function (frame) {
              var functionName = frame.functionName,
                  lineNumber = frame.lineNumber,
                  columnNumber = frame.columnNumber,
                  _originalLineNumber = frame._originalLineNumber;

              if (_originalLineNumber != null) {
                return frame;
              }

              var fileName = frame.fileName;

              if (fileName) {
                // The web version of this module only provides POSIX support, so Windows
                // paths like C:\foo\\baz\..\\bar\ cannot be normalized.
                // A simple solution to this is to replace all `\` with `/`, then
                // normalize afterwards.
                fileName = path.normalize(fileName.replace(/[\\]+/g, '/'));
              }

              if (fileName == null) {
                return frame;
              }

              var fN = fileName;
              var source = map.getSources() // Prepare path for normalization; see comment above for reasoning.
              .map(function (s) {
                return s.replace(/[\\]+/g, '/');
              }).filter(function (p) {
                p = path.normalize(p);
                var i = p.lastIndexOf(fN);
                return i !== -1 && i === p.length - fN.length;
              }).map(function (p) {
                return {
                  token: p,
                  seps: count(path.sep, path.normalize(p)),
                  penalties: count('node_modules', p) + count('~', p)
                };
              }).sort(function (a, b) {
                var s = Math.sign(a.seps - b.seps);

                if (s !== 0) {
                  return s;
                }

                return Math.sign(a.penalties - b.penalties);
              });

              if (source.length < 1 || lineNumber == null) {
                return new StackFrame(null, null, null, null, null, functionName, fN, lineNumber, columnNumber, null);
              }

              var sourceT = source[0].token;

              var _map$getGeneratedPosi = map.getGeneratedPosition(sourceT, lineNumber, // $FlowFixMe
              columnNumber),
                  line = _map$getGeneratedPosi.line,
                  column = _map$getGeneratedPosi.column;

              var originalSource = map.getSource(sourceT);
              return new StackFrame(functionName, fileUri, line, column || null, getLinesAround(line, contextLines, fileContents || []), functionName, fN, lineNumber, columnNumber, getLinesAround(lineNumber, contextLines, originalSource));
            }));

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _unmap.apply(this, arguments);
}

export { unmap };
export default unmap;