"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.api = api;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _socketclusterClient = _interopRequireDefault(require("socketcluster-client"));

var _jsan = require("jsan");

var actions = _interopRequireWildcard(require("../constants/socketActionTypes"));

var _instances = require("../reducers/instances");

var _actionTypes = require("../constants/actionTypes");

var _actions = require("../actions");

var _monitorActions = require("../utils/monitorActions");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var socket;
var store;

function emit(_ref) {
  var type = _ref.message,
      id = _ref.id,
      instanceId = _ref.instanceId,
      action = _ref.action,
      state = _ref.state;
  socket.emit(id ? "sc-".concat(id) : 'respond', {
    type: type,
    action: action,
    state: state,
    instanceId: instanceId
  });
}

function startMonitoring(channel) {
  if (channel !== store.getState().socket.baseChannel) return;
  store.dispatch({
    type: actions.EMIT,
    message: 'START'
  });
}

function dispatchRemoteAction(_ref2) {
  var message = _ref2.message,
      action = _ref2.action,
      state = _ref2.state,
      toAll = _ref2.toAll;
  var instances = store.getState().instances;
  var instanceId = (0, _instances.getActiveInstance)(instances);
  var id = !toAll && instances.options[instanceId].connectionId;
  store.dispatch({
    type: actions.EMIT,
    message: message,
    action: action,
    state: (0, _monitorActions.nonReduxDispatch)(store, message, instanceId, action, state, instances),
    instanceId: instanceId,
    id: id
  });
}

function monitoring(request) {
  if (request.type === 'DISCONNECTED') {
    store.dispatch({
      type: _actionTypes.REMOVE_INSTANCE,
      id: request.id
    });
    return;
  }

  if (request.type === 'START') {
    store.dispatch({
      type: actions.EMIT,
      message: 'START',
      id: request.id
    });
    return;
  }

  if (request.type === 'ERROR') {
    store.dispatch((0, _actions.showNotification)(request.payload));
    return;
  }

  store.dispatch({
    type: _actionTypes.UPDATE_STATE,
    request: request.data ? _objectSpread(_objectSpread({}, request.data), {}, {
      id: request.id
    }) : request
  });
  var instances = store.getState().instances;
  var instanceId = request.instanceId || request.id;

  if (instances.sync && instanceId === instances.selected && (request.type === 'ACTION' || request.type === 'STATE')) {
    socket.emit('respond', {
      type: 'SYNC',
      state: (0, _jsan.stringify)(instances.states[instanceId]),
      id: request.id,
      instanceId: instanceId
    });
  }
}

function subscribe(channelName, subscription) {
  var channel = socket.subscribe(channelName);
  if (subscription === _actionTypes.UPDATE_STATE) channel.watch(monitoring);else {
    var watcher = function watcher(request) {
      store.dispatch({
        type: subscription,
        request: request
      });
    };

    channel.watch(watcher);
    socket.on(channelName, watcher);
  }
}

function handleConnection() {
  socket.on('connect', function (status) {
    store.dispatch({
      type: actions.CONNECT_SUCCESS,
      payload: {
        id: status.id,
        authState: socket.authState,
        socketState: socket.state
      },
      error: status.authError
    });

    if (socket.authState !== actions.AUTHENTICATED) {
      store.dispatch({
        type: actions.AUTH_REQUEST
      });
    }
  });
  socket.on('disconnect', function (code) {
    store.dispatch({
      type: actions.DISCONNECTED,
      code: code
    });
  });
  socket.on('subscribe', function (channel) {
    store.dispatch({
      type: actions.SUBSCRIBE_SUCCESS,
      channel: channel
    });
  });
  socket.on('unsubscribe', function (channel) {
    socket.unsubscribe(channel);
    socket.unwatch(channel);
    socket.off(channel);
    store.dispatch({
      type: actions.UNSUBSCRIBE,
      channel: channel
    });
  });
  socket.on('subscribeFail', function (error) {
    store.dispatch({
      type: actions.SUBSCRIBE_ERROR,
      error: error,
      status: 'subscribeFail'
    });
  });
  socket.on('dropOut', function (error) {
    store.dispatch({
      type: actions.SUBSCRIBE_ERROR,
      error: error,
      status: 'dropOut'
    });
  });
  socket.on('error', function (error) {
    store.dispatch({
      type: actions.CONNECT_ERROR,
      error: error
    });
  });
}

function connect() {
  if (process.env.NODE_ENV === 'test') return;
  var connection = store.getState().connection;

  try {
    socket = _socketclusterClient.default.create(connection.options);
    handleConnection();
  } catch (error) {
    store.dispatch({
      type: actions.CONNECT_ERROR,
      error: error
    });
    store.dispatch((0, _actions.showNotification)(error.message || error));
  }
}

function disconnect() {
  if (socket) {
    socket.disconnect();
    socket.off();
  }
}

function login() {
  socket.emit('login', {}, function (error, baseChannel) {
    if (error) {
      store.dispatch({
        type: actions.AUTH_ERROR,
        error: error
      });
      return;
    }

    store.dispatch({
      type: actions.AUTH_SUCCESS,
      baseChannel: baseChannel
    });
    store.dispatch({
      type: actions.SUBSCRIBE_REQUEST,
      channel: baseChannel,
      subscription: _actionTypes.UPDATE_STATE
    });
    store.dispatch({
      type: actions.SUBSCRIBE_REQUEST,
      channel: 'report',
      subscription: _actionTypes.UPDATE_REPORTS
    });
  });
}

function getReport(reportId) {
  socket.emit('getReport', reportId, function (error, data) {
    if (error) {
      store.dispatch({
        type: _actionTypes.GET_REPORT_ERROR,
        error: error
      });
      return;
    }

    store.dispatch({
      type: _actionTypes.GET_REPORT_SUCCESS,
      data: data
    });
    store.dispatch((0, _actions.importState)(data.payload));
  });
}

function api(inStore) {
  store = inStore;
  return function (next) {
    return function (action) {
      var result = next(action);

      switch (action.type) {
        case actions.CONNECT_REQUEST:
          connect();
          break;

        case actions.RECONNECT:
          disconnect();
          if (action.options.type !== 'disabled') connect();
          break;

        case actions.AUTH_REQUEST:
          login();
          break;

        case actions.SUBSCRIBE_REQUEST:
          subscribe(action.channel, action.subscription);
          break;

        case actions.SUBSCRIBE_SUCCESS:
          startMonitoring(action.channel);
          break;

        case actions.EMIT:
          if (socket) emit(action);
          break;

        case _actionTypes.LIFTED_ACTION:
          dispatchRemoteAction(action);
          break;

        case _actionTypes.GET_REPORT_REQUEST:
          getReport(action.report);
          break;
      }

      return result;
    };
  };
}