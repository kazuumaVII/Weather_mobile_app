import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

import { UPDATE_STATE, SET_STATE, LIFTED_ACTION, SELECT_INSTANCE, REMOVE_INSTANCE, TOGGLE_PERSIST, TOGGLE_SYNC, SET_PERSIST } from '../constants/actionTypes';
import { DISCONNECTED } from '../constants/socketActionTypes';
import parseJSON from '../utils/parseJSON';
import { recompute } from '../utils/updateState';
export var instancesInitialState = {
  selected: null,
  current: 'default',
  sync: false,
  connections: {},
  options: {
    default: {
      features: {}
    }
  },
  states: {
    default: {
      actionsById: {},
      computedStates: [],
      currentStateIndex: -1,
      nextActionId: 0,
      skippedActionIds: [],
      stagedActionIds: []
    }
  }
};

function updateState(state, request, id, serialize) {
  var payload = request.payload;
  var actionsById = request.actionsById;

  if (actionsById) {
    payload = _objectSpread(_objectSpread({}, payload), {}, {
      actionsById: parseJSON(actionsById, serialize),
      computedStates: parseJSON(request.computedStates, serialize)
    });

    if (request.type === 'STATE' && request.committedState) {
      payload.committedState = payload.computedStates[0].state;
    }
  } else {
    payload = parseJSON(payload, serialize);
  }

  var newState;
  var liftedState = state[id] || state.default;
  var action = request.action && parseJSON(request.action, serialize) || {};

  switch (request.type) {
    case 'INIT':
      newState = recompute(state.default, payload, {
        action: {
          type: '@@INIT'
        },
        timestamp: action.timestamp || Date.now()
      });
      break;

    case 'ACTION':
      {
        var isExcess = request.isExcess;
        var nextActionId = request.nextActionId || liftedState.nextActionId + 1;
        var maxAge = request.maxAge;

        if (Array.isArray(action)) {
          // Batched actions
          newState = liftedState;

          for (var i = 0; i < action.length; i++) {
            newState = recompute(newState, request.batched ? payload : payload[i], action[i], newState.nextActionId + 1, maxAge, isExcess);
          }
        } else {
          newState = recompute(liftedState, payload, action, nextActionId, maxAge, isExcess);
        }

        break;
      }

    case 'STATE':
      newState = payload;

      if (newState.computedStates.length <= newState.currentStateIndex) {
        newState.currentStateIndex = newState.computedStates.length - 1;
      }

      break;

    case 'PARTIAL_STATE':
      {
        var _maxAge = request.maxAge;
        var _nextActionId = payload.nextActionId;
        var stagedActionIds = payload.stagedActionIds;
        var computedStates = payload.computedStates;
        var oldActionsById;
        var oldComputedStates;
        var committedState;

        if (_nextActionId > _maxAge) {
          var oldStagedActionIds = liftedState.stagedActionIds;
          var excess = oldStagedActionIds.indexOf(stagedActionIds[1]);
          var key;

          if (excess > 0) {
            oldComputedStates = liftedState.computedStates.slice(excess - 1);
            oldActionsById = _objectSpread({}, liftedState.actionsById);

            for (var _i = 1; _i < excess; _i++) {
              key = oldStagedActionIds[_i];
              if (key) delete oldActionsById[key];
            }

            committedState = computedStates[0].state;
          } else {
            oldActionsById = liftedState.actionsById;
            oldComputedStates = liftedState.computedStates;
            committedState = liftedState.committedState;
          }
        } else {
          oldActionsById = liftedState.actionsById;
          oldComputedStates = liftedState.computedStates;
          committedState = liftedState.committedState;
        }

        computedStates = [].concat(_toConsumableArray(oldComputedStates), _toConsumableArray(computedStates));
        var statesCount = computedStates.length;
        var currentStateIndex = payload.currentStateIndex;
        if (statesCount <= currentStateIndex) currentStateIndex = statesCount - 1;
        newState = _objectSpread(_objectSpread({}, liftedState), {}, {
          actionsById: _objectSpread(_objectSpread({}, oldActionsById), payload.actionsById),
          computedStates: computedStates,
          currentStateIndex: currentStateIndex,
          nextActionId: _nextActionId,
          stagedActionIds: stagedActionIds,
          committedState: committedState
        });
        break;
      }

    case 'LIFTED':
      newState = liftedState;
      break;

    default:
      return state;
  }

  if (request.liftedState) newState = _objectSpread(_objectSpread({}, newState), request.liftedState);
  return _objectSpread(_objectSpread({}, state), {}, _defineProperty({}, id, newState));
}

export function dispatchAction(state, _ref) {
  var action = _ref.action;

  if (action.type === 'JUMP_TO_STATE' || action.type === 'JUMP_TO_ACTION') {
    var _id = state.selected || state.current;

    var liftedState = state.states[_id];
    var currentStateIndex = action.type === 'JUMP_TO_STATE' ? action.index : liftedState.stagedActionIds.indexOf(action.actionId);
    return _objectSpread(_objectSpread({}, state), {}, {
      states: _objectSpread(_objectSpread({}, state.states), {}, _defineProperty({}, _id, _objectSpread(_objectSpread({}, liftedState), {}, {
        currentStateIndex: currentStateIndex
      })))
    });
  }

  return state;
}

function removeState(state, connectionId) {
  var instanceIds = state.connections[connectionId];
  if (!instanceIds) return state;

  var connections = _objectSpread({}, state.connections);

  var options = _objectSpread({}, state.options);

  var states = _objectSpread({}, state.states);

  var selected = state.selected;
  var current = state.current;
  var sync = state.sync;
  delete connections[connectionId];
  instanceIds.forEach(function (id) {
    if (id === selected) {
      selected = null;
      sync = false;
    }

    if (id === current) {
      var inst = Object.keys(connections)[0];
      if (inst) current = connections[inst][0];else current = 'default';
    }

    delete options[id];
    delete states[id];
  });
  return {
    selected: selected,
    current: current,
    sync: sync,
    connections: connections,
    options: options,
    states: states
  };
}

function init(_ref2, connectionId, current) {
  var type = _ref2.type,
      action = _ref2.action,
      name = _ref2.name,
      _ref2$libConfig = _ref2.libConfig,
      libConfig = _ref2$libConfig === void 0 ? {} : _ref2$libConfig;
  var lib;
  var actionCreators;
  var creators = libConfig.actionCreators || action;
  if (typeof creators === 'string') creators = JSON.parse(creators);
  if (Array.isArray(creators)) actionCreators = creators;
  if (type === 'STATE') lib = 'redux';
  return {
    name: libConfig.name || name || current,
    connectionId: connectionId,
    explicitLib: libConfig.type,
    lib: lib,
    actionCreators: actionCreators,
    features: libConfig.features ? libConfig.features : {
      lock: lib === 'redux',
      export: libConfig.type === 'redux' ? 'custom' : true,
      import: 'custom',
      persist: true,
      pause: true,
      reorder: true,
      jump: true,
      skip: true,
      dispatch: true,
      sync: true,
      test: true
    },
    serialize: libConfig.serialize
  };
}

export function instances() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : instancesInitialState;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case UPDATE_STATE:
      {
        var request = action.request;
        if (!request) return state;
        var connectionId = action.id || request.id;
        var current = request.instanceId || connectionId;
        var connections = state.connections;
        var options = state.options;

        if (typeof state.options[current] === 'undefined') {
          connections = _objectSpread(_objectSpread({}, state.connections), {}, _defineProperty({}, connectionId, [].concat(_toConsumableArray(connections[connectionId] || []), [current])));
          options = _objectSpread(_objectSpread({}, options), {}, _defineProperty({}, current, init(request, connectionId, current)));
        }

        return _objectSpread(_objectSpread({}, state), {}, {
          current: current,
          connections: connections,
          options: options,
          states: updateState(state.states, request, current, options[current].serialize)
        });
      }

    case SET_STATE:
      return _objectSpread(_objectSpread({}, state), {}, {
        states: _objectSpread(_objectSpread({}, state.states), {}, _defineProperty({}, getActiveInstance(state), action.newState))
      });

    case TOGGLE_PERSIST:
      return _objectSpread(_objectSpread({}, state), {}, {
        persisted: !state.persisted
      });

    case SET_PERSIST:
      return _objectSpread(_objectSpread({}, state), {}, {
        persisted: action.payload
      });

    case TOGGLE_SYNC:
      return _objectSpread(_objectSpread({}, state), {}, {
        sync: !state.sync
      });

    case SELECT_INSTANCE:
      return _objectSpread(_objectSpread({}, state), {}, {
        selected: action.selected,
        sync: false
      });

    case REMOVE_INSTANCE:
      return removeState(state, action.id);

    case LIFTED_ACTION:
      {
        if (action.message === 'DISPATCH') return dispatchAction(state, action);

        if (action.message === 'IMPORT') {
          var _id2 = state.selected || state.current;

          if (state.options[_id2].features.import === true) {
            return _objectSpread(_objectSpread({}, state), {}, {
              states: _objectSpread(_objectSpread({}, state.states), {}, _defineProperty({}, _id2, parseJSON(action.state)))
            });
          }
        }

        return state;
      }

    case DISCONNECTED:
      return instancesInitialState;

    default:
      return state;
  }
}
export var getActiveInstance = function getActiveInstance(instances) {
  return instances.selected || instances.current;
};